diff --git a/iocore/hostdb/HostDB.cc b/iocore/hostdb/HostDB.cc
index eb5b541..cad00ae 100644
--- a/iocore/hostdb/HostDB.cc
+++ b/iocore/hostdb/HostDB.cc
@@ -1385,6 +1385,52 @@ HostDBContinuation::lookup_done(IpAddr const &ip, char const *aname, bool around
 }
 
 
+// Lookup done, insert into the local table, return data to the
+// calling continuation or to the calling cluster node.
+//
+HostDBInfo *
+HostDBContinuation::unixpath_done(char const* aname, bool around_robin, unsigned int ttl_seconds, SRVHosts * srv)
+{
+  HostDBInfo *i = NULL;
+
+  ink_assert(this_ethread() == hostDB.lock_for_bucket((int) (fold_md5(md5.hash) % hostDB.buckets))->thread_holding);
+  if (!aname || !aname[0]) {
+
+    i = insert(hostdb_ip_fail_timeout_interval);        // currently ... 0
+    i->round_robin = false;
+    i->reverse_dns = !is_byname() && !is_srv();
+
+    i->set_failed();
+  } else {
+
+    if (hostdb_ip_timeout_interval * 60 > ttl_seconds)
+      ttl_seconds = hostdb_ip_timeout_interval * 60;
+
+    HOSTDB_SUM_DYN_STAT(hostdb_ttl_stat, ttl_seconds);
+    i = insert(ttl_seconds);
+    Debug("hostdb", "done %s TTL %d", aname, ttl_seconds);
+
+    sockaddr *sa = i->ip();
+    ink_strlcpy((char *) sa->sa_data, aname, TS_UNIX_SIZE);
+    sa->sa_family = AF_UNIX;
+    i->is_srv = false;
+    i->round_robin = around_robin;
+    i->reverse_dns = false;
+
+    if (md5.host_name != aname) {
+      ink_strlcpy(md5_host_name_store, aname, sizeof(md5_host_name_store));
+    }
+    i->is_srv = false;
+
+ }
+
+  if (from_cont)
+    do_put_response(from, i, from_cont);
+  ink_assert(!i->round_robin || !i->reverse_dns);
+
+  return i;
+}
+
 int
 HostDBContinuation::dnsPendingEvent(int event, Event *e)
 {
@@ -2023,6 +2069,15 @@ HostDBContinuation::do_dns()
       hostdb_cont_free(this);
       return;
     }
+    if ('/' == md5.host_name[0]) {
+      // check path format // What the heck does that mean? 
+      if (action.continuation) {
+        HostDBInfo *r = unixpath_done(md5.host_name, false, HOST_DB_MAX_TTL, NULL);
+        reply_to_cont(action.continuation, r);
+      }
+      hostdb_cont_free(this);
+      return;
+    }
   }
   if (hostdb_lookup_timeout) {
     timeout = mutex->thread_holding->schedule_in(this, HRTIME_SECONDS(hostdb_lookup_timeout));
diff --git a/iocore/hostdb/I_HostDBProcessor.h b/iocore/hostdb/I_HostDBProcessor.h
index 39a58a1..380e435 100644
--- a/iocore/hostdb/I_HostDBProcessor.h
+++ b/iocore/hostdb/I_HostDBProcessor.h
@@ -307,7 +307,7 @@ struct HostDBInfo {
   bool
   failed()
   {
-    return !((is_srv && data.srv.srv_offset) || (reverse_dns && data.hostname_offset) || ats_is_ip(ip()));
+    return !((is_srv && data.srv.srv_offset) || (reverse_dns && data.hostname_offset) || ats_is_supported_family(ip()));
   }
   void
   set_failed()
diff --git a/iocore/hostdb/P_HostDBProcessor.h b/iocore/hostdb/P_HostDBProcessor.h
index 22b095d..50f170b 100644
--- a/iocore/hostdb/P_HostDBProcessor.h
+++ b/iocore/hostdb/P_HostDBProcessor.h
@@ -510,6 +510,7 @@ struct HostDBContinuation : public Continuation {
     return md5.db_mark == HOSTDB_MARK_SRV;
   }
   HostDBInfo *lookup_done(IpAddr const &ip, char const *aname, bool round_robin, unsigned int attl, SRVHosts *s = NULL);
+  HostDBInfo *unixpath_done(char const* aname, bool round_robin, unsigned int attl, SRVHosts * s = NULL);
   bool do_get_response(Event *e);
   void do_put_response(ClusterMachine *m, HostDBInfo *r, Continuation *cont);
   int failed_cluster_request(Event *e);
diff --git a/iocore/net/UnixConnection.cc b/iocore/net/UnixConnection.cc
index e0aaef3..0184cdb 100644
--- a/iocore/net/UnixConnection.cc
+++ b/iocore/net/UnixConnection.cc
@@ -243,7 +243,7 @@ Connection::open(NetVCOptions const &opt)
     family = opt.local_ip.family();
   } else {
     // No local address specified, so use family option if possible.
-    family = ats_is_ip(opt.ip_family) ? opt.ip_family : AF_INET;
+    family = ats_is_supported_family(opt.ip_family) ? opt.ip_family : AF_INET;
     local_addr.setToAnyAddr(family);
     is_any_address = true;
     local_addr.port() = htons(opt.local_port);
diff --git a/lib/ts/ink_inet.cc b/lib/ts/ink_inet.cc
index 7de24fa..ad21b84 100644
--- a/lib/ts/ink_inet.cc
+++ b/lib/ts/ink_inet.cc
@@ -175,7 +175,11 @@ ats_ip_ntop(const struct sockaddr *addr, char *dst, size_t size)
 char const *
 ats_ip_family_name(int family)
 {
-  return AF_INET == family ? "IPv4" : AF_INET6 == family ? "IPv6" : "Unspec";
+  return AF_INET == family ? "IPv4"
+    : AF_INET6 == family ? "IPv6"
+    : AF_UNIX == family ? "Unix"
+    : "Unspec"
+    ;
 }
 
 char const *
@@ -303,6 +307,8 @@ ats_ip_hash(sockaddr const *addr)
     zret.i = ats_ip4_addr_cast(addr);
   } else if (ats_is_ip6(addr)) {
     ink_code_md5(const_cast<uint8_t *>(ats_ip_addr8_cast(addr)), TS_IP6_SIZE, zret.c);
+  } else if (ats_is_unix(addr)) {
+    ink_code_md5((uint8_t*)(ats_unix_path_cast(addr)), TS_UNIX_SIZE, zret.c);
   }
   return zret.i;
 }
diff --git a/lib/ts/ink_inet.h b/lib/ts/ink_inet.h
index 1754bd6..8be1769 100644
--- a/lib/ts/ink_inet.h
+++ b/lib/ts/ink_inet.h
@@ -27,6 +27,7 @@
 
 #include <netinet/in.h>
 #include <netdb.h>
+#include <sys/un.h>
 #include <sys/socket.h>
 #include "ts/ink_memory.h"
 #include "ts/ink_apidefs.h"
@@ -70,6 +71,7 @@ union IpEndpoint {
   struct sockaddr sa;       ///< Generic address.
   struct sockaddr_in sin;   ///< IPv4
   struct sockaddr_in6 sin6; ///< IPv6
+  struct sockaddr_un sun;   ///< Unix
 
   /** Assign from a socket address.
       The entire address (all parts) are copied if the @a ip is valid.
@@ -193,6 +195,9 @@ const char *ats_ip_ntop(const struct sockaddr *addr, char *dst, size_t size);
 /// Size in bytes of an IPv6 address.
 static size_t const TS_IP6_SIZE = sizeof(in6_addr);
 
+/// Size in bytes of an Unix socket path.
+static size_t const TS_UNIX_SIZE = sizeof(sockaddr_un::sun_path);
+
 /// Reset an address to invalid.
 /// @note Useful for marking a member as not yet set.
 inline void
@@ -229,6 +234,35 @@ ats_is_ip(IpEndpoint const *addr)
 {
   return addr && (AF_INET == addr->sa.sa_family || AF_INET6 == addr->sa.sa_family);
 }
+
+/// Test for suppoted address family.
+/// @return @c true if the address is supported, @c false otherwise.
+inline bool ats_is_supported_family(sockaddr const* addr) {
+  return addr
+    && (AF_INET == addr->sa_family || AF_INET6 == addr->sa_family || AF_UNIX == addr->sa_family);
+}
+/// @return @c true if the address is supported, @c false otherwise.
+inline bool ats_is_supported_family(IpEndpoint const* addr) {
+  return addr
+    && (AF_INET == addr->sa.sa_family || AF_INET6 == addr->sa.sa_family || AF_UNIX == addr->sa.sa_family);
+}
+/// Test for IP protocol.
+/// @return @c true if the value is an suported address family, @c false otherwise.
+inline bool ats_is_supported_family(int family) {
+  return AF_INET == family || AF_INET6 == family || AF_UNIX == family;
+}
+/// Test for UNIX domain.
+/// @return @c true if the the address is unix path, @c false otherwise.
+inline bool ats_is_unix(sockaddr const* addr) {
+  return addr && AF_UNIX == addr->sa_family;
+}
+/// Test for Unix domain.
+/// @note Convenience overload.
+/// @return @c true if the address is unix path, @c false otherwise.
+inline bool ats_is_unix(IpEndpoint const* addr) {
+  return addr && AF_UNIX == addr->sa.sa_family;
+}
+
 /// Test for IP protocol.
 /// @return @c true if the value is an IP address family, @c false otherwise.
 inline bool
@@ -415,18 +449,39 @@ ats_ip6_cast(sockaddr const &a)
   return *static_cast<sockaddr_in6 const *>(static_cast<void const *>(&a));
 }
 
+inline sockaddr_un* ats_unix_cast(sockaddr* a) {
+  return static_cast<sockaddr_un*>(static_cast<void*>(a));
+}
+inline sockaddr_un const* ats_unix_cast(sockaddr const* a) {
+  return static_cast<sockaddr_un const*>(static_cast<void const*>(a));
+}
+inline sockaddr_un& ats_unix_cast(sockaddr& a) {
+  return *static_cast<sockaddr_un*>(static_cast<void*>(&a));
+}
+inline sockaddr_un const& ats_unix_cast(sockaddr const& a) {
+  return *static_cast<sockaddr_un const*>(static_cast<void const*>(&a));
+}
+
 /// @return The @c sockaddr size for the family of @a addr.
 inline size_t
 ats_ip_size(sockaddr const *addr ///< Address object.
             )
 {
-  return AF_INET == addr->sa_family ? sizeof(sockaddr_in) : AF_INET6 == addr->sa_family ? sizeof(sockaddr_in6) : 0;
+  return AF_INET == addr->sa_family ? sizeof(sockaddr_in)
+    : AF_INET6 == addr->sa_family ? sizeof(sockaddr_in6)
+    : AF_UNIX == addr->sa_family ? sizeof(sockaddr_un)
+    : 0
+    ;
 }
 inline size_t
 ats_ip_size(IpEndpoint const *addr ///< Address object.
             )
 {
-  return AF_INET == addr->sa.sa_family ? sizeof(sockaddr_in) : AF_INET6 == addr->sa.sa_family ? sizeof(sockaddr_in6) : 0;
+  return AF_INET == addr->sa.sa_family ? sizeof(sockaddr_in)
+    : AF_INET6 == addr->sa.sa_family ? sizeof(sockaddr_in6)
+    : AF_UNIX == addr->sa.sa_family ? sizeof(sockaddr_un)
+    : 0
+    ;
 }
 /// @return The size of the IP address only.
 inline size_t
@@ -560,6 +615,28 @@ ats_ip6_addr_cast(IpEndpoint const *ip)
   return ip->sin6.sin6_addr;
 }
 
+/** Access the Unix socket path..
+
+    This function returens sockaddr_un.sun_path offset address. 
+    It must check sockaddr type is sockaddr_un before using.
+    @note This is direct access to the address so it will be in
+    unix path string.
+
+    @return A reference to the unix path in @a addr.
+*/
+inline char* ats_unix_path_cast(sockaddr* addr) {
+  return ats_unix_cast(addr)->sun_path;
+}
+inline char const* ats_unix_path_cast(sockaddr const* addr) {
+  return ats_unix_cast(addr)->sun_path;
+}
+inline char* ats_unix_path_cast(IpEndpoint* ip) {
+  return ip->sun.sun_path;
+}
+inline char const* ats_unix_path_cast(IpEndpoint const* ip) {
+  return ip->sun.sun_path;
+}
+
 /** Cast an IP address to an array of @c uint32_t.
     @note The size of the array is dependent on the address type which
     must be checked independently of this function.
@@ -743,6 +820,9 @@ ats_ip_copy(sockaddr *dst,      ///< Destination object.
     case AF_INET6:
       n = sizeof(sockaddr_in6);
       break;
+    case AF_UNIX:
+      n = sizeof(sockaddr_un);
+      break;
     }
   }
   if (n) {
@@ -882,6 +962,8 @@ ats_ip_addr_port_eq(sockaddr const *lhs, sockaddr const *rhs)
       zret = ats_ip4_cast(lhs)->sin_addr.s_addr == ats_ip4_cast(rhs)->sin_addr.s_addr;
     else if (AF_INET6 == lhs->sa_family)
       zret = 0 == memcmp(&ats_ip6_cast(lhs)->sin6_addr, &ats_ip6_cast(rhs)->sin6_addr, sizeof(in6_addr));
+    else if (AF_UNIX == lhs->sa_family)
+      zret = 0 == strncmp(ats_unix_cast(lhs)->sun_path, ats_unix_cast(rhs)->sun_path, TS_UNIX_SIZE);
   }
   return zret;
 }
@@ -1482,7 +1564,7 @@ IpEndpoint::host_order_port() const
 inline bool
 IpEndpoint::isValid() const
 {
-  return ats_is_ip(this);
+  return ats_is_supported_family(this);
 }
 
 inline bool
diff --git a/mgmt/RecordsConfig.cc b/mgmt/RecordsConfig.cc
index f3a2566..fd5b344 100644
--- a/mgmt/RecordsConfig.cc
+++ b/mgmt/RecordsConfig.cc
@@ -1044,7 +1044,7 @@ static const RecordElement RecordsConfig[] =
   ,
   {RECT_CONFIG, "proxy.config.hostdb.storage_path", RECD_STRING, TS_BUILD_CACHEDIR, RECU_DYNAMIC, RR_NULL, RECC_NULL, NULL, RECA_NULL}
   ,
-  {RECT_CONFIG, "proxy.config.hostdb.storage_size", RECD_INT, "33554432", RECU_DYNAMIC, RR_NULL, RECC_NULL, NULL, RECA_NULL}
+  {RECT_CONFIG, "proxy.config.hostdb.storage_size", RECD_INT, "61571072", RECU_DYNAMIC, RR_NULL, RECC_NULL, NULL, RECA_NULL}
   ,
   //       # in minutes (all three)
   //       #  0 = obey, 1 = ignore, 2 = min(X,ttl), 3 = max(X,ttl)
diff --git a/proxy/http/HttpSM.cc b/proxy/http/HttpSM.cc
index 7350581..5e8c5be 100644
--- a/proxy/http/HttpSM.cc
+++ b/proxy/http/HttpSM.cc
@@ -2083,7 +2083,7 @@ HttpSM::process_hostdb_info(HostDBInfo *r)
     if (ret) {
       t_state.host_db_info = *ret;
       ink_release_assert(!t_state.host_db_info.reverse_dns);
-      ink_release_assert(ats_is_ip(t_state.host_db_info.ip()));
+      ink_release_assert(ats_is_supported_family(t_state.host_db_info.ip()));
     }
   } else {
     DebugSM("http", "[%" PRId64 "] DNS lookup failed for '%s'", sm_id, t_state.dns_info.lookup_name);
@@ -4564,10 +4564,12 @@ HttpSM::do_http_server_open(bool raw)
 
   ink_assert(pending_action == NULL);
 
-  if (false == t_state.api_server_addr_set) {
-    ink_assert(t_state.current.server->dst_addr.host_order_port() > 0);
-  } else {
-    ink_assert(t_state.current.server->dst_addr.port() != 0); // verify the plugin set it to something.
+  if (ip_family != AF_UNIX) {
+    if (false == t_state.api_server_addr_set) {
+      ink_assert(t_state.current.server->dst_addr.host_order_port() > 0);
+    } else {
+      ink_assert(t_state.current.server->dst_addr.port() != 0); // verify the plugin set it to something.
+    }
   }
 
   char addrbuf[INET6_ADDRPORTSTRLEN];
diff --git a/proxy/http/HttpTransact.cc b/proxy/http/HttpTransact.cc
index 8c7e582..24d2c6e 100644
--- a/proxy/http/HttpTransact.cc
+++ b/proxy/http/HttpTransact.cc
@@ -5608,6 +5608,11 @@ HttpTransact::initialize_state_variables_from_request(State *s, HTTPHdr *obsolet
 
   s->next_hop_scheme = s->scheme = incoming_request->url_get()->scheme_get_wksidx();
 
+  char *unix_sock = s->url_map.getUnixSocket();
+  if(unix_sock) {
+      s->server_info.name = unix_sock;
+  }
+
   // With websockets we need to make an outgoing request
   // as http or https.
   // We switch back to HTTP or HTTPS for the next hop
diff --git a/proxy/http/remap/RemapConfig.cc b/proxy/http/remap/RemapConfig.cc
index 8b5f58e..8828285 100644
--- a/proxy/http/remap/RemapConfig.cc
+++ b/proxy/http/remap/RemapConfig.cc
@@ -669,6 +669,12 @@ remap_check_option(const char **argv, int argc, unsigned long findmode, int *_re
           idx = i;
         }
         ret_flags |= REMAP_OPTFLG_INTERNAL;
+      } else if (!strncasecmp(argv[i], "unix_socket=", 12)) {
+        if ((findmode & REMAP_OPTFLG_UNIX_SOCK) != 0)
+          idx = i;
+        if (argptr)
+          *argptr = &argv[i][12];
+        ret_flags |= REMAP_OPTFLG_UNIX_SOCK;
       }
 
       if ((findmode & ret_flags) && !argptr) {
@@ -1107,6 +1113,30 @@ remap_parse_config_bti(const char *path, BUILD_TABLE_INFO *bti)
       }
     }
 
+    if ((bti->remap_optflg & REMAP_OPTFLG_UNIX_SOCK) != 0) {
+      int idx = 0;
+      char *c;
+      int ret = remap_check_option((const char **)bti->argv, bti->argc, REMAP_OPTFLG_UNIX_SOCK, &idx);
+      if (ret & REMAP_OPTFLG_UNIX_SOCK) {
+        c = strchr(bti->argv[idx], (int) '=');
+        size_t unix_socket_len = strlen(c);
+        if(unix_socket_len > 0 && unix_socket_len < TS_UNIX_SIZE) {
+            struct stat s;
+            int err = stat(++c, &s);
+            if(!err & S_ISSOCK(s.st_mode)) {
+                new_mapping->unix_socket = (char *)ats_malloc(unix_socket_len);
+                memcpy(new_mapping->unix_socket, c , unix_socket_len);
+            } else {
+                errStr = "wrong unix_socket file";
+                goto MAP_ERROR;
+            }
+        } else {
+            errStr = "wrong unix_socket name";
+            goto MAP_ERROR;
+        }
+      }
+    }
+
     map_from = bti->paramv[1];
     length = UrlWhack(map_from, &origLength);
 
diff --git a/proxy/http/remap/RemapConfig.h b/proxy/http/remap/RemapConfig.h
index 300eaea..555f7a3 100644
--- a/proxy/http/remap/RemapConfig.h
+++ b/proxy/http/remap/RemapConfig.h
@@ -39,6 +39,7 @@ class UrlRewrite;
 #define REMAP_OPTFLG_ACTION 0x0020u           /* "action=" option (used for ACL filtering) */
 #define REMAP_OPTFLG_INTERNAL 0x0040u         /* only allow internal requests to hit this remap */
 #define REMAP_OPTFLG_IN_IP 0x0080u            /* "in_ip=" option (used for ACL filtering)*/
+#define REMAP_OPTFLG_UNIX_SOCK 0x0100u        /* "unix_sock=" option (used for Unix Socket) */
 #define REMAP_OPTFLG_MAP_ID 0x0800u           /* associate a map ID with this rule */
 #define REMAP_OPTFLG_INVERT 0x80000000u       /* "invert" the rule (for src_ip at least) */
 #define REMAP_OPTFLG_ALL_FILTERS (REMAP_OPTFLG_METHOD | REMAP_OPTFLG_SRC_IP | REMAP_OPTFLG_ACTION | REMAP_OPTFLG_INTERNAL)
diff --git a/proxy/http/remap/UrlMapping.cc b/proxy/http/remap/UrlMapping.cc
index 45651fd..72f9e7e 100644
--- a/proxy/http/remap/UrlMapping.cc
+++ b/proxy/http/remap/UrlMapping.cc
@@ -31,7 +31,7 @@
 url_mapping::url_mapping(int rank /* = 0 */)
   : from_path_len(0), fromURL(), toUrl(), homePageRedirect(false), unique(false), default_redirect_url(false),
     optional_referer(false), negative_referer(false), wildcard_from_scheme(false), tag(NULL), filter_redirect_url(NULL),
-    referer_list(0), redir_chunk_list(0), filter(NULL), _plugin_count(0), _rank(rank)
+    referer_list(0), redir_chunk_list(0), filter(NULL), _plugin_count(0), unix_socket(NULL), _rank(rank)
 {
   memset(_plugin_list, 0, sizeof(_plugin_list));
   memset(_instance_data, 0, sizeof(_instance_data));
@@ -93,6 +93,7 @@ url_mapping::~url_mapping()
   acl_filter_rule *afr;
 
   tag = (char *)ats_free_null(tag);
+  unix_socket = (char *)ats_free_null(unix_socket);
   filter_redirect_url = (char *)ats_free_null(filter_redirect_url);
 
   while ((r = referer_list) != 0) {
diff --git a/proxy/http/remap/UrlMapping.h b/proxy/http/remap/UrlMapping.h
index f86744c..92ce0ee 100644
--- a/proxy/http/remap/UrlMapping.h
+++ b/proxy/http/remap/UrlMapping.h
@@ -112,6 +112,7 @@ public:
   acl_filter_rule *filter; // acl filtering (list of rules)
   unsigned int _plugin_count;
   LINK(url_mapping, link); // For use with the main Queue linked list holding all the mapping
+  char *unix_socket;
 
   int
   getRank() const
@@ -155,6 +156,12 @@ public:
     return _mapping ? &(_mapping->fromURL) : NULL;
   };
 
+  char *
+  getUnixSocket() const
+  {
+    return (_mapping && _mapping->unix_socket)? _mapping->unix_socket : NULL;
+  };
+
   url_mapping *
   getMapping() const
   {
